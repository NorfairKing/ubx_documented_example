* UBX example
  UNDER CONSTRUCTION
** Install ubx and ubx_cmake
   - Look at the [[https://github.com/UbxTeam/microblx][ubx readme]] to find out which dependencies there and install them on your system.
*** Workspace
    Make a ubx workspace directory.
    #+BEGIN_EXAMPLE
    ~ $ mkdir ubx
    ~ $ cd ubx
    #+END_EXAMPLE
*** [[https://github.com/UbxTeam/microblx][Microblx]]
    #+BEGIN_EXAMPLE
    ~/ubx $ git clone https://github.com/UbxTeam/microblx.git
    #+END_EXAMPLE
    You might want to use the 'dev' branch.
    #+BEGIN_EXAMPLE
    ~/ubx $ cd microblx
    ~/ubx/microblx $ git checkout dev
    ~/ubx/microblx $ cd ..
    #+END_EXAMPLE
*** [[https://github.com/haianos/microblx_cmake][Ubx Cmake]]
    #+BEGIN_EXAMPLE
    ~/ubx$ git clone https://github.com/haianos/microblx_cmake.git
    #+END_EXAMPLE
    You might also want to use the 'dev' branch here.
    #+BEGIN_EXAMPLE
    ~/ubx $ cd microblx_cmake
    ~/ubx/microblx_cmake $ git checkout dev
    ~/ubx/microblx_cmake $ cd ..
    #+END_EXAMPLE
*** Sourceme.sh ifle
    Write a sourceme.sh file for yourself
    This file needs to be sourced in every terminal session where you want to use ubx.
    | Variable          | Meaning                                                                 |
    |-------------------+-------------------------------------------------------------------------|
    | UBX_ROOT          | Points to the original microblx root path                               |
    | UBX_MODULE        | Same as UBX_ROOT                                                        |
    | UBX_MODULES       | Points to the dynamic library folder where the blocks will be installed |
    | UBX_MODELS        | Points to the models folder                                             |

    #+BEGIN_EXAMPLE
    ~/ubx $ cat sourceme.sh # TODO WORK THIS OUT BETTER
    export UBX_ROOT=$HOME/ubx/microblx
    export UBX_MODULE=$HOME/ubx/microblx
    source $UBX_ROOT/env.sh
    export UBX_MODULES=$HOME/ubx/ubxinstall/lib/ubx
    export UBX_MODELS=$HOME/ubx/ubx_example/models
    #+END_EXAMPLE
    You might want to put in your shell's startup script.
      - bash:
      #+BEGIN_EXAMPLE
      ~/ubx $ echo 'source path/to/sourceme.sh' >> .bashrc
      #+END_EXAMPLE
      - zsh:
      #+BEGIN_EXAMPLE
      ~/ubx $ echo 'source path/to/sourceme.sh' >> .zshrc
      #+END_EXAMPLE
*** Compile microblx
    To compile ubx, the sourceme.sh file has to be sourced.
    #+BEGIN_EXAMPLE
    ~/ubx $ source sourceme.sh
    #+END_EXAMPLE
    After that, just run make in the ubx directory.
    #+BEGIN_EXAMPLE
    ~/ubx $ cd microblx
    ~/ubx/microblx $ make # Don't use multiple core option -jn
    #+END_EXAMPLE
*** Current situation
    At this point, you ~/ubx directory should look like this:
    #+BEGIN_EXAMPLE
    ~/ubx
    |- microblx
    |- microblx_cmake
    |- sourceme.sh
    #+END_EXAMPLE

** Making a package
   The process of making a package consists of the following steps.
   1. Design the model for the ubx package.
   2. Design the model for the blocks.
   3. Generate the code for the package.
   4. Implement the types
   5. Implement the blocks
   6. Building with cmake
*** Designing the package model.
    A package contains a set of blocks types.

    To design the package model, write a package model (.pkg) file.
    Example:

#+BEGIN_EXAMPLE
$ cat example_pkg.pkg
return pkg
{
  -- The name of the package
  name="example",
  
  -- The path to the directory where the package will be generated (optional)
  -- (No trailing slash)
  path=".",
      
  -- The dependencies of the package (optional)
  -- These could be dependencies on other packages, blocks, types or libraries
  dependencies = {
    -- name: the name of the dependecy
    -- type: a string represeting the type of dependency
    --   |- cmake: >TODO< what does this mean?
    -- required: whether or not the dependency is required
    { name="dependencyname", type="cmake", required=true },
  },
  
  -- The types that are used in the package (optional)
  -- All types have to be declared, not only custom types. >TODO<
  -- >TODO< {Is it the name of the directory, a relative path or an absolute path?}
  types = {
    -- name: The name of the type
    -- dir: The directory in which the type is declared (optional)
    { name="my_type", dir="types" },
    { name="vector", dir="types" },
    { name="robot_data", dir="types" },
  },
  
  -- The blocks that are defined in the package (optional)
  blocks = {
    -- name: The name of the block
    -- file: The file in which the block is declared
    -- src_dir: The source directory in which the code will be generated. (optional)
    -- >TODO< {Is it the name of the directory, a relative path or an absolute path?}
    { name="myblock", file="examples/example_block.blx", src_dir="src" },
    { name="myblock2", file="examples/example_block2.blx", src_dir="src2" },
  },
  
  -- The modules that the package provides (optional)
  modules = {
    -- name: The name of the module
    -- blocks: The names of the blocks in the module
    { name="mylib", blocks={"myblock"} },
    { name="anotherlib", blocks={"myblock2"} } ,
  },
}
#+END_EXAMPLE
    Note the comma's at the end of each item in a list.
    The last item can to have such a comma.

    You can find a real example in the models subdirectory of this repository
*** Designing the block models
**** Generic block
     To design a block, write a block model file (.blx) file.
     #+BEGIN_EXAMPLE
     return block
     {
       -- The name of the block
       name="blockname",
       -- The metadata of the block (optional)
       meta_data="metadata",
       -- >TODO< what is port_cache for?
       port_cache=true,

       -- The types used for this block (optional)
       types = {
         -- name: the name of the type
         -- class: the class of the type
         -- |- struct: Currently only structs are available
         -- |- enum: NOT IMPLEMENTED YET
         -- doc: A description of the type (optional)
         { name="typename", class='struct', doc='description' }, -- Enum will follow once implemented in C
         { name="configname2", class='struct', doc='description' }, -- Enum will follow once implemented in C
       },
    
       -- The configuration values for this block (optional)
       configurations= {
         -- name: the name of the type
         -- type_name: the type of the config value
         -- len: the size of an instance of the type (in bytes) (optional)
         -- doc: a description of the documentation of the config value (optional)
         { name="configname1", type_name="configtype", len=5 },
         { name="configname2", type_name="struct configstructtype" },
       },
    
       -- The ports for this block (optional)
       ports = {
         -- name: the name of the port
         -- in_type_name: the type name for input data (optional)
         -- in_data_len: the lenght (in bytes) for the input data type (optional)
         -- in_type_name: the type name for output data (optional)
         -- in_data_len: the lenght (in bytes) for the output data type (optional)
         -- doc: a description of the port (optional)
         { name="portname1", in_type_name="double", in_data_len=8, doc="description" },
         { name="portname2", out_type_name="int", out_data_len=4 },
       },
          
       -- The provided operations for this block
       -- start: whether to provide a start function
       -- stop: whether to provide a stop function
       -- step: whether to provide a step function
       operations = { start=true, stop=true, step=true }
     }
     #+END_EXAMPLE

**** cblock
     Not specifically implemented yet
     - Model only one trigger, and have it be an input trigger.
**** iblock
     An iblock model differs in only one aspect: the operations field.
     #+BEGIN_EXAMPLE
     [...]
       -- The provided operations for this block
       -- read: whether to provide a read function
       -- write: whether  to provide a write function
       operations = { write=true, read=true}
     [...]
     #+END_EXAMPLE
**** sblock
     Not specifically implemented yet
     - Model no ports
*** Generating the code for your package


*** Implement the types
*** Implement the blocks
*** Building and installing your package
#+BEGIN_EXAMPLE
CMAKE_BUILD_TYPE                                                                       
CMAKE_INSTALL_PREFIX             /home/syd/ubx/ubxinstall                              
INSTALL_BIN_APPS_DIR             bin                                                   
INSTALL_CMAKE_DIR                share/ubx/cmake                                       
INSTALL_INCLUDE_DIR              include/ubx                                           
INSTALL_LIB_BLOCKS_DIR           lib/ubx/blocks                                        
INSTALL_LIB_TYPES_DIR            lib/ubx/types                                         
UBX_LIBRARY                      /home/syd/ubx/microblx/src/libubx.so
#+END_EXAMPLE
** Creating an ubx system composition
COMING SOON
*** Designing the composition
*** Creating a launch script
*** Launch the application
    
